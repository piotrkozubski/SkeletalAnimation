# Polygon Map exporter

import bpy
import mathutils
import math

bl_info = {
    "name": "PMAP exporter",
    "author": "Piotr Kozubski",
    "version": (0, 5, 6, 6),
    "blender": (2, 7, 2),
	"location": "File > Export > PMAP exporter",
	"category": "Import-Export",
}

class VertexType:
    x = 0.0
    y = 0.0
    z = 0.0
    nx = 0.0
    ny = 0.0
    nz = 0.0
    u = 0.0
    v = 0.0
    bone1I = -1
    bone1W = 0
    bone2I = -1
    bone2W = 0
    d = 0
    
class PolygonType:
    v = []
    nx = 0
    ny = 0
    nz = 0
    
class BoneQuat:
    t = [0, 0, 0]  # translation 0-2
    q = [1, 0, 0, 0]  # quaternion 0-3
    
class Bone:
    id = -1
    keyFramesDict = {}  # key = frame id, value = BoneQuat object
    
def getBoneNameFromFC(fcurve):
    list = fcurve.data_path.split('"')
    return list[1]
    
def findBoneIndex(groupName, bones):
    for idx, bone in enumerate(bones):
        if bone.name == groupName:
            return idx
    print("ERROR, cannot find bone id for vertex! groupName: " + groupName);
    return 0
    
def rotateQuatAxis(rot_mat, quat):
    #print("input matrix " + str(rot_mat))
    #print("input quat " + str(quat))
    
    rot_quat = rot_mat.to_quaternion()

    if quat[0] > 1.0:
        quat[0] = 1.0
    if quat[0] < -1.0:
        quat[0] = -1.0
    angle = math.acos(quat[0]) * 2
    angle_deg = angle * 57.2957795
    sin_half = math.sin(angle / 2)
    if (sin_half != 0):
        axis_x = quat[1] / sin_half
        axis_y = quat[2] / sin_half
        axis_z = quat[3] / sin_half
    else:
        axis_x = 0
        axis_y = 0
        axis_z = 0
    
    #print("unpacked axis: " + str(axis_x) + ", " + str(axis_y) + ", " + str(axis_z) + ", " + str(angle_deg))
    
    v = mathutils.Vector((axis_x, axis_y, axis_z))
    new_axis = rot_mat * v
    
    return mathutils.Quaternion(new_axis, angle)
    
    
def findIndex(list, lookFor):
    for elIdx, element in enumerate(list):
        if element == lookFor:
            return elIdx
    return -1
    
def printVertAndFace(f, vertexList, polygonList):
    f.write("#number of vertex\n")
    f.write("%d\n" % (len(vertexList)))     #vertices num
    f.write("#number of triangles\n")
    f.write("%d\n" % len(polygonList))    #faces num
    f.write("#texture coordinates flag\n")
    f.write("1\n")                                #texture coord num

    f.write("#vertex list (x, y, z, u, v)\n")
    for v in vertexList:
        if v.d == 0:
            f.write("%.10f, " % v.x)
            f.write("%.10f, " % v.y)
            f.write("%.10f, " % v.z)
            
            f.write("%.10f, " % v.u)
            f.write("%.10f, " % v.v)
            
            f.write("\n")
    f.write("#triangle list (vertex 1 index, vertex 2 index, vertex 3 index)\n")
    for p in polygonList:
        f.write("%d, " % p.v[0])
        f.write("%d, " % p.v[1])
        f.write("%d, " % p.v[2])
        f.write("%.10f, " % p.nx)
        f.write("%.10f, " % p.ny)
        f.write("%.10f\n" % p.nz)
    
def VertexEqual(vertexList, idx, idxDup):
    print("VertexEqual: " + ", " + str(idx) + ", " + str(idxDup))
    result = (vertexList[idx].x == vertexList[idxDup].x) and (vertexList[idx].y == vertexList[idxDup].y) and (vertexList[idx].z == vertexList[idxDup].z) and (vertexList[idx].u == vertexList[idxDup].u) and (vertexList[idx].v == vertexList[idxDup].v)
    print("result = " + str(result));
    return result
    
def ItemVertexEqual(vertexList, v, vDup):
    print("ItemVertexEqual: " + str(vertexList.index(v)) + ", " + str(vertexList.index(vDup)))
    result = (v.x == vDup.x) and (v.y == vDup.y) and (v.z == vDup.z) and (v.u == vDup.u) and (v.v == vDup.v)
    if (result):
        print("result = " + str(result));
    return result
    
def mesh_triangulate(me):
    import bmesh
    bm = bmesh.new()
    bm.from_mesh(me)
    bmesh.ops.triangulate(bm, faces=bm.faces)
    bm.to_mesh(me)
    bm.free()

def write_some_data(context, filepath, use_some_setting):
    print("running write_some_data...")
    f = open(filepath, 'w', encoding='utf-8')
    #f.write("#PMAP generated by Blender export addon\n")
    
    # =============== MESHES ====================
    item = bpy.context.scene.objects.active.copy()
    if item.type != 'MESH':
        print("Object type must be 'MESH'")
    else:
        print("item name: " + item.name)
        #triangulate faces of the mesh
        mesh_triangulate(item.data)

        # Be sure tessface & co are available!
        item.data.calc_tessface()
        
        # get object world matrix
        matrix_world = item.matrix_world
        
        # COLLECTING VERTICES, FACES
        vertexList = []
        polygonList = []
        dict = {}
        vertex_counter = 0
        for polIdx, face in enumerate(item.data.polygons):
            vIdx = []
            for vert, loop in zip(face.vertices, face.loop_indices):
            # vertex
                v = VertexType()
                final_v = matrix_world * item.data.vertices[vert].co;
                v.x = final_v[0]
                v.y = final_v[1]
                v.z = final_v[2]
            # normal
                v.nx = item.data.vertices[vert].normal[0]
                v.ny = item.data.vertices[vert].normal[1]
                v.nz = item.data.vertices[vert].normal[2]
            # uv
                if (len(item.data.uv_layers)):
                    v.u = item.data.uv_layers.active.data[loop].uv[0]
                    v.v = item.data.uv_layers.active.data[loop].uv[1]

                key = v.x, v.y, v.z, v.u, v.v
                if dict.get(key) == None:
                    dict[key] = vertex_counter
                    vertex_counter = vertex_counter + 1
                    vertexList.append(v)
                vIdx.append(dict[key])
            
            p = PolygonType()
            p.v = vIdx
            #vn1 = mathutils.Vector((vertexList[p.v[0]].x, vertexList[p.v[0]].y, vertexList[p.v[0]].z))
            #vn2 = mathutils.Vector((vertexList[p.v[1]].x, vertexList[p.v[1]].y, vertexList[p.v[1]].z))
            #vn3 = vn1.cross(vn2)
            p.nx = face.normal[0]
            p.ny = face.normal[1]
            p.nz = face.normal[2]
            polygonList.append(p)


        # EXPORTING VERTICES, FACES TO FILE
        #f.write("%d\n" % (len(vertexList) - deletedV))     #vertices num
        printVertAndFace(f, vertexList, polygonList)                

    f.close()
    print("done")

    return {'FINISHED'}


# ExportHelper is a helper class, defines filename and
# invoke() function which calls the file selector.
from bpy_extras.io_utils import ExportHelper
from bpy.props import StringProperty, BoolProperty, EnumProperty
from bpy.types import Operator


class ExportSomeData(Operator, ExportHelper):
    """This appears in the tooltip of the operator and in the generated docs"""
    bl_idname = "export_test.some_data"  # important since its how bpy.ops.import_test.some_data is constructed
    bl_label = "Export Some Data"

    # ExportHelper mixin class uses this
    filename_ext = ".pmap"

    filter_glob = StringProperty(
            default="*.pmap",
            options={'HIDDEN'},
            maxlen=255,  # Max internal buffer length, longer would be clamped.
            )

    # List of operator properties, the attributes will be assigned
    # to the class instance from the operator settings before calling.
    use_setting = BoolProperty(
            name="Example Boolean",
            description="Example Tooltip",
            default=True,
            )

    type = EnumProperty(
            name="Example Enum",
            description="Choose between two items",
            items=(('OPT_A', "First Option", "Description one"),
                   ('OPT_B', "Second Option", "Description two")),
            default='OPT_A',
            )

    def execute(self, context):
        return write_some_data(context, self.filepath, self.use_setting)


# Only needed if you want to add into a dynamic menu
def menu_func_export(self, context):
    self.layout.operator(ExportSomeData.bl_idname, text="PMAP exporter")


def register():
    bpy.utils.register_class(ExportSomeData)
    bpy.types.INFO_MT_file_export.append(menu_func_export)


def unregister():
    bpy.utils.unregister_class(ExportSomeData)
    bpy.types.INFO_MT_file_export.remove(menu_func_export)


if __name__ == "__main__":
    register()

    # test call
    bpy.ops.export_test.some_data('INVOKE_DEFAULT')
